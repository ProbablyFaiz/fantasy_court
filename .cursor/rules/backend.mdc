---
description: python_backend
globs: backend/**/*
alwaysApply: false
---

- Typing is very important, so be sure to type any function arguments/outputs.
  - In Python, the lowercase types (e.g. ‘list’, ’dict’) should be used where available instead of importing from the typing package. Note that lowercase types do not need to be imported.
  - Use `SomeType | None` instead of `Optional[SomeType]`.
- Pathlib Paths should be used over the equivalent os functions.
- Use SQLAlchemy 2.x ORM syntax, not 1.x.
  - E.g., you should write queries as `db.execute(<query var or the query inline>).scalars().all()` instead of `db.query(Model).all()`.
  - Some helpful context: my projects are typically structured such that models are in <project_name>.db.models, and you can create a session with `from <project_name>.db.session import get_session` (e.g. `from cdle.db.session`) and then `session = get_session()`.
- Use Pydantic 2.x syntax, not 1.x.
- Prefer Pydantic models over dataclasses when applicable.
- Prefer full imports for lowercase (non-class, usually) symbols, e.g. `import tenacity ... @tenacity.retry` or `import tqdm ... tqdm.tqdm()`, and `from` imports for uppercase constants and classes, e.g., `from perm.db.models import Chunk, CHUNK_SEPARATOR`.

- For writing standalone scripts:
    - We like progress bars! *Long-running, important* loops should use a tqdm progress bar with appropriate concise desc parameter set. When postfixes are necessary (e.g. if tracking the number of records skipped in some loop operation), define a `pbar` variable separately, and then update it and set the postfix within the loop manually.
    - To avoid confusion, always do "import tqdm" and then "tqdm.tqdm" for the progress bar instead of "from tqdm import tqdm". Repeat, use `import tqdm` and `tqdm.tqdm(...)` in code, NEVER `from tqdm import tqdm` and `tqdm(...)`.
- When writing Python scripts, we have a utility library called `rl`. Some notes on `rl` and the way we use it:
    - We have an enhanced version of click, the Python CLI library. The only difference in usage from the regular click is one does `import rl.utils.click as click` instead of `import click`.
    - When using logging in a program, use `rl`'s preconfigured logger: `from rl.utils import LOGGER`.
    - `rl` has (among others) the following IO functions, usable within `import rl.utils.io` (do not `from import`, use the absolute import):
        - `def get_data_path(*args) -> Path` — Generally, whenever a CLI script deals with input and output files/dirs, the default paths (which should typically be configurable via CLI options) are set on some subpath of the data path. E.g. `_DEFAULT_OUTPUT_DIR = rl.utils.io.get_data_path("raw_codes", "sf")`.
        - `def read_jsonl(filename: str | Path) -> Iterable[Any]` — yield an iterable of JSON-parsed items from a JSONL file, used as `for record in rl.utils.io.read_jsonl(...):` etc.
        - `def download(url: str, dest: str | Path) -> None` — Downloads a given url to a file with a progress bar, so when doing pure downloads this is preferable.
- When creating click CLIs, obey the following conventions:
    - Unless otherwise instructed, prefer options, not arguments. Provide concise and descriptive help text for each option. Provide both a long (--foo) and short (-f) for all options unless doing so would lead to a conflict.
    - Default values for options should be stored as private global constants (`_ALL_CAPS`) at the top of the file and then referenced (`default=_DEFAULT_INPUT_PATH`) in the option decorator.
    - When declaring options that refer to file paths or directories, file paths should be suffixed with '_path', while directory paths should be suffixed with '_dir'. Path options should always be declared with `type=click.Path([any applicable exists/okay options], path_type=Path)` and the resulting function argument should therefore be typed as a pathlib `Path`.

- When using the Gemini API, use the newer `google-genai` SDK, NOT the older `google-generativeai` SDK. Use the stateless `generate_content`, e.g.,:
```python
from google import genai
from google.genai import types

client = genai.Client()

response = client.models.generate_content(
    model="gemini-2.5-flash",
    config=types.GenerateContentConfig(
        system_instruction="You are a cat. Your name is Neko."),
    contents=[types.Content(text="Hello there")]
)
```

## Testing Philosophy
- **Avoid mocks** - Use real database models and the existing PostgreSQL testing infrastructure
- **Use fixtures** - Create proper object graphs with pytest fixtures to avoid repetition and ensure foreign key constraints are satisfied
- **Test behavior, not implementation** - Focus on what the code does, not how it does it
- **Be pragmatic** - Write tests that give confidence in critical functionality without over-testing trivial code. Your instinct is usually to over-test, so always dial back from your default.
