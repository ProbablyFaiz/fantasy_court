---
description: frontend
globs: frontend/**/*
alwaysApply: false
---
- When using React, we use Typescript and typically build most UI elements with Tailwind/shadcn
    - Please use shadcn components where available or installable. When asked to use icons, use Lucide icons.
- When designing UI, you should build components that are aesthetically pleasing, modern in design, and consistent with the app's existing conventions.
- Generally speaking, import project files relative to the src directory using the `@/` alias, e.g. `@/features/home/CTA.tsx`

## API Client Usage (React Query)

- Our API client is auto-generated and provides TanStack Query (React Query) integration:
  - Import types from `@/client` (e.g., `import { TaskListItem } from "@/client"`)
  - Import services like `DefaultService` from `@/client`
  - Import query options from `@/client/@tanstack/react-query.gen`

- API endpoint naming convention follows these patterns:
  - GET endpoints for single items generate `readXOptions` functions (e.g., `readTaskOptions`)
  - GET endpoints for paginated lists generate `listXOptions` functions (e.g., `listTaskRunPredictionsOptions`)
  - Query keys are available as `readXQueryKey` and `listXQueryKey` functions with the same arguments as the `readXOptions` functions.

- When using the client with React Query:
  - For read operations, spread the options from the generated functions:
    ```typescript
    const { data } = useQuery({
      ...readTaskOptions({ path: { task_id: taskId } }),
    });
    ```
        - Note that useQuery does not have `onSuccess` or `onError` callbacks. To take actions on success and failure, you must use `useEffect` as is typical in React.
  - For mutations, use the service directly:
    ```typescript
    const mutation = useMutation({
      mutationFn: (taskId: number) =>
        DefaultService.archiveTask({ path: { task_id: taskId } }),
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: getTasksQueryKey() });
      },
    });
    ```

- When implementing pagination:
  - Use the `PaginationControl` component from `@/components` (`import PaginationControl from "@/components/PaginationControl"`):
```typescript
interface PaginationControlProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  onPageHover?: (page: number) => void;
}
```
  - Implement prefetching on hover for pagination items using `onPageHover`
  - Use `keepPreviousData` option with paginated queries for smoother transitions:
    ```typescript
    const { data } = useQuery({
      ...listSomethingOptions({ query: { page: currentPage, limit: pageSize } }),
      placeholderData: keepPreviousData,
    });
    ```

- Performance best practices:
  - Implement prefetching when hovering over list items
  - Always invalidate related queries after mutations that affect the data
  - For heavily nested components, consider using QueryClient directly for prefetching
