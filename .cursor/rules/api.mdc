---
description: api
globs: backend/perm/api/**/*
alwaysApply: false
---
- For FastAPI apps:
   - By convention, all endpoints should be decorated with the response_model and an operation ID (in camel case, e.g. `listEvalIssues`). GET endpoints which return lists/paginated lists should be named as list{plural object in camel case}, for single objects, `read{singular object in camel case}`, e.g. `readEvalIssue`.
   - When declaring endpoint dependencies, use the Annotated syntax, e.g., `db: Annotated[Session, Depends(get_db)]`, NOT the `= Depends(get_db)` default argument syntax.
   - Words in urls should be separated by underscores, not dashes. E.g. `issue_histories` not `issue-histories`.
   - By convention, list endpoints should return a paginated object using the PaginatedBase generic in backend/perm/api/interfaces.py. Here is an example:
```python
@router.get(
    "/tasks", response_model=PaginatedBase[TaskListItem], operation_id="listTasks"
)
def list_tasks(
    db: Annotated[Session, Depends(get_db)],
    project_id: Annotated[int | None, Query()] = None,
    search: Annotated[str | None, Query()] = None,
    page: Annotated[int, Query(ge=1)] = 1,
    limit: Annotated[int, Query(ge=1, le=100)] = 50,
):
    query = (
        # omitted
    )
    if project_id is not None:
        ...  # omitted
    if search is not None:
        ...  # omitted
    query = (
       ...  # omitted
    )
    tasks = db.execute(query).scalars().all()
    return PaginatedBase(
        items=tasks,
        total=total,
        page=page,
        size=limit,
    )
```
- When writing dependencies for the API in `backend/blank/api/deps.py`, you should be sure to eager-load any related models (via `.options` on the query) that will be sent as part of the defined interface in `backend/blank/api/interfaces.py`. In almost 100% of cases, the correct approach is `selectinload`; `joinedload` has unpredictable and sometimes dire performance consequences.
- When defining interfaces, typically follow the convention of defining a model's `<model_name>Base` with the small and direct fields of a model, a `<model_name>Read` which is the full-fat version of the model that we would by convention return from a `read<model_name>` endpoint that has any of the related objects as well. And a `<model_name>Item` interface that would typically be returned in a related object's list child. E.g. a `ProjectRead` might have a `permit_applications` field which is typed as `list[PermitApplicationItem]`.
    - This is a general practice but not a hard rule, and we can depart from it where particular items require related objects; the direct fields contain a large blob; etc.
